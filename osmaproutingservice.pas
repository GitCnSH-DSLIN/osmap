(*
  OsMap components for offline rendering and routing functionalities
  based on OpenStreetMap data

  Copyright (C) 2019  Sergey Bodrov

  This source is ported from libosmscout library
  Copyright (C) 2012  Tim Teulings
  Copyright (C) 2017  Lukas Karas

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA

*)
(*
  OsMap routing service
routing\RoutingService
  RoutePosition
  RouterParameter
  RoutingProgress -> TRoutingProgressEvent
  RoutingParameter
  RoutingService
    RNode
    RNodeCostCompare -> CompareRNodes()
    VNode
    ClosedNodeHasher
routing\AbstractRoutingService
  RoutingResult
  RoutePoints
  RoutePointsResult
  RouteDescriptionResult
  RouteWayResult
*)
unit OsMapRoutingService;

{$ifdef FPC}
{$mode objfpc}{$H+}
{$endif}

interface

uses
  Classes, SysUtils, OsMapTypes, OsMapGeometry, OsMapUtils, OsMapObjTypes,
  OsMapObjects, OsMapRouting;

const
  { Relative filename of the intersection data file }
  FILENAME_INTERSECTIONS_DAT = 'intersections.dat';
  { Relative filename of the intersection index file }
  FILENAME_INTERSECTIONS_IDX = 'intersections.idx';
  { Relative filebase name for touting data as generated by default by the importer }
  DEFAULT_FILENAME_BASE = 'router';

type
  { Start or end position of a route calculation }

  { TRoutePosition }

  TRoutePosition = object
    Obj: TObjectFileRef;
    NodeIndex: Integer;
    DatabaseId: TMapDatabaseId;

    procedure Init(const AObj: TObjectFileRef; ANodeIndex: Integer; ADatabaseId: TMapDatabaseId);
    function IsValid(): Boolean; // Obj.IsValid
  end;

  { Database instance initialization parameter to influence the behavior of the database
    instance.
    The following groups attributes are currently available:
    - Switch for showing debug information }

  { TRouterParameter }

  TRouterParameter = object
    IsDebugPerformance: Boolean;
    procedure Init();
  end;

  { Optional callback object for monitoring routing progress }
  TRoutingProgressEvent = procedure (const ACurDistance, ATotalDistance: TDistance) of object;

  { Parameter object for routing calculations. Holds all optional
    flags and callback objects that can be passed to the router }
  TRoutingParameter = object
    Breaker: TBreakerObject;
    OnProgress: TRoutingProgressEvent;
  end;

  {  A path in the routing graph from one node to the next (expressed via the target object)
     with additional information as required by the A* algorithm. }
  TRNode = record
    Id: TMapDBId;      // The file offset of the current route node
    Node: TRouteNode;  // The current route node
    Prev: TMapDBId;    // The file offset of the previous route node
    Obj: TObjectFileRef; // The object (way/area) visited from the current route node

    CurrentCost: Double;  // The cost of the current up to the current node
    EstimateCost: Double; // The estimated cost from here to the target
    OverallCost: Double;  // The overall costs (currentCost+estimateCost)

    IsAccess: Boolean;    // Flags to signal, if we had access ("access restrictions") to this node
  end;

  TRNodeList = object
  private
    FHash: TSimpleStringHash;
  public
    Items: array of TRNode;
  end;

  { Minimum required data for a node in the ClosedSet.
    The ClosedSet is the set of routing nodes that have been
  already handled.
    From the VNode list from the last routing node back to the start
  the route is recalculated by following the previousNode chain. }
  TVNode = record
    CurNode: TMapDBId;   // FileOffset of this route node
    PrevNode: TMapDBId;  // FileOffset of the previous route node
    Obj: TObjectFileRef; // The object (way/area) visited from the current route node
  end;

  TVNodeList = object
    Items: array of TVNode;
  end;

  { Helper class for calculating hash codes for
    VNode instances to make it usable in std::unordered_set. }
  TClosedNodeHasher = object
    OpenList: TRNodeList;
    ClosedSet: TVNodeList;
  end;

  { Abstract algorithms for routing }

  { TRoutingService }

  TRoutingService = class
  public
    function GetDataFilename(const AFilenameBase: string): string;
    function GetData2Filename(const AFilenameBase: string): string;
    function GetIndexFilename(const AFilenameBase: string): string;

    //procedure AfterConstruction; override;
    //procedure BeforeDestruction; override;
  end;

  { Result of a routing calculation. This object is always returned.
    In case of an routing error it however may not contain a valid route
    (route is empty).
    TODO: Adapt it to the same style as RoutePointsResult and Co. }

  { TRoutingResult }

  TRoutingResult = object
    Route: TRouteData;
    CurrentMaxDistance: TDistance;
    OverallDistance: TDistance;

    function Success(): Boolean;
  end;

  TRoutePoints = object
    Points: TGeoPointArray;
  end;

  TRoutePointsResult = record
    IsSuccess: Boolean;
    Points: TGeoPointArray;
  end;

  TRouteDescriptionResult = record
    IsSuccess: Boolean;
    Description: TRouteDescription;
  end;

  TRouteWayResult = record
    IsSuccess: Boolean;
    Way: TMapWay;
  end;

  TRouteNodeMap = class(TStringList)
    procedure SetValue(const AKey: TMapDBId; const AValue: TRouteNode);
    function FindValue(const AKey: TMapDBId; out AValue: TRouteNode): Boolean;
  end;

  TRoutingState = class;

  TAbstractRoutingService = class(TRoutingService)
  protected
    FIsDebugPerformance: Boolean;

    function GetVehicle(AState: TRoutingState): TVehicleType; virtual;

    function CanUse(AState: TRoutingState; ADatabase: TMapDatabaseID; AWay: TMapWay): Boolean; virtual;
    function CanUseForward(AState: TRoutingState; ADatabase: TMapDatabaseID; AWay: TMapWay): Boolean; virtual;
    function CanUseBackward(AState: TRoutingState; ADatabase: TMapDatabaseID; AWay: TMapWay): Boolean; virtual;

    function GetCosts(AState: TRoutingState; ADatabase: TMapDatabaseID;
      const ARouteNode: TRouteNode; APathIndex: Integer): Double; virtual; overload;
    function GetCosts(AState: TRoutingState; ADatabase: TMapDatabaseID;
      AWay: TMapWay; AWayLength: TDistance): Double; virtual; overload;

    function GetEstimateCosts(AState: TRoutingState; ADatabase: TMapDatabaseID;
      ATargetDistance: TDistance): Double; virtual;
    function GetCostLimit(AState: TRoutingState; ADatabase: TMapDatabaseID;
      ATargetDistance: TDistance): Double; virtual;

    function GetRouteNodes(const ARouteNodeIds: TMapDBIdArray; ARouteNodeMap: TRouteNodeMap): Boolean;
    { Return the route node for the given database offset }
    function GetRouteNode(const AId: TMapDBId; out ANode: TRouteNode): Boolean;

    function GetWayByOffset(const AOffset: TMapDBFileOffset; AWay: TMapWay): Boolean;
    fdggfh
  end;

  function RNode(const AId: TMapDBId;
    const ANode: TRouteNode;
    const AObj: TObjectFileRef;
    const APrev: TMapDBId): TRNode;

  function CompareRNodes(const A, B: TRNode): Integer;

implementation

function RNode(const AId: TMapDBId;
  const ANode: TRouteNode;
  const AObj: TObjectFileRef;
  const APrev: TMapDBId): TRNode;
begin
  Result.Id := AId;
  Result.Node := ANode;
  Result.Prev := APrev;
  Result.Obj.Assign(AObj);
  Result.CurrentCost := 0;
  Result.EstimateCost := 0;
  Result.OverallCost := 0;
  Result.IsAccess := True;
end;

function CompareRNodes(const A, B: TRNode): Integer;
begin
  if A.OverallCost > B.OverallCost then
    Result := 1
  else
  if A.OverallCost < B.OverallCost then
    Result := -1
  else
    Result := 0;
end;

{ TRoutePosition }

procedure TRoutePosition.Init(const AObj: TObjectFileRef; ANodeIndex: Integer;
  ADatabaseId: TMapDatabaseId);
begin
  Obj.Assign(AObj);
  NodeIndex := ANodeIndex;
  DatabaseId := ADatabaseId;
end;

function TRoutePosition.IsValid(): Boolean;
begin
  Result := Obj.IsValid();
end;

{ TRouterParameter }

procedure TRouterParameter.Init();
begin
  IsDebugPerformance := False;
end;

{ TRoutingService }

function TRoutingService.GetDataFilename(const AFilenameBase: string): string;
begin
  Result := AFilenameBase + '.dat';
end;

function TRoutingService.GetData2Filename(const AFilenameBase: string): string;
begin
  Result := AFilenameBase + '2.dat';
end;

function TRoutingService.GetIndexFilename(const AFilenameBase: string): string;
begin
  Result := AFilenameBase + '.idx';
end;

{ TRoutingResult }

function TRoutingResult.Success(): Boolean;
begin
  Result := (not Route.IsEmpty());
end;

end.

