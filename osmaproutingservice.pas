(*
  OsMap components for offline rendering and routing functionalities
  based on OpenStreetMap data

  Copyright (C) 2019  Sergey Bodrov

  This source is ported from libosmscout library
  Copyright (C) 2012  Tim Teulings
  Copyright (C) 2017  Lukas Karas

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307  USA

*)
(*
  OsMap routing service
routing\RoutingService
routing\AbstractRoutingService ...
*)
unit OsMapRoutingService;

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, OsMapTypes, OsMapGeometry, OsMapUtils, OsMapObjTypes,
  OsMapRouting;

const
  { Relative filename of the intersection data file }
  FILENAME_INTERSECTIONS_DAT = 'intersections.dat';
  { Relative filename of the intersection index file }
  FILENAME_INTERSECTIONS_IDX = 'intersections.idx';
  { Relative filebase name for touting data as generated by default by the importer }
  DEFAULT_FILENAME_BASE = 'router';

type
  { Start or end position of a route calculation }
  TRoutePosition = object
    Obj: TObjectFileRef;
    NodeIndex: Integer;
    DatabaseId: TMapDatabaseId;

    procedure Init(const AObj: TObjectFileRef; ANodeIndex: Integer; ADatabaseId: TMapDatabaseId);
  end;

  { Database instance initialization parameter to influence the behavior of the database
    instance.
    The following groups attributes are currently available:
    - Switch for showing debug information }
  TRouterParameter = object
    DebugPerformance: Boolean;
    procedure Init();
  end;

  { Optional callback object for monitoring routing progress }
  TRoutingProgressEvent = procedure (const ACurDistance, ATotalDistance: TDistance) of object;

  { Parameter object for routing calculations. Holds all optional
    flags and callback objects that can be passed to the router }
  TRoutingParameter = object
    Breaker: TBreakerObject;
    OnProgress: TRoutingProgressEvent;
  end;

  {  A path in the routing graph from one node to the next (expressed via the target object)
     with additional information as required by the A* algorithm. }
  TRNode = record
    Id: TMapDBId;      // The file offset of the current route node
    Node: TRouteNode;  // The current route node
    Prev: TMapDBId;    // The file offset of the previous route node
    Obj: TObjectFileRef; // The object (way/area) visited from the current route node

    CurrentCost: Double;  // The cost of the current up to the current node
    EstimateCost: Double; // The estimated cost from here to the target
    OverallCost: Double;  // The overall costs (currentCost+estimateCost)

    IsAccess: Boolean;    // Flags to signal, if we had access ("access restrictions") to this node
  end;

  TRNodeList = object
  private
    FHash: TSimpleStringHash;
  public
    Items: array of TRNode;
  end;

  { Minimum required data for a node in the ClosedSet.
    The ClosedSet is the set of routing nodes that have been
  already handled.
    From the VNode list from the last routing node back to the start
  the route is recalculated by following the previousNode chain. }
  TVNode = record
    CurNode: TMapDBId;   // FileOffset of this route node
    PrevNode: TMapDBId;  // FileOffset of the previous route node
    Obj: TObjectFileRef; // The object (way/area) visited from the current route node
  end;

  TVNodeList = object
    Items: array of TVNode;
  end;

  { Abstract algorithms for routing }
  TRoutingService = class
  private
    FOpenList: TRNodeList;
    FClosedSet: TVNodeList;
  public
    property OpenList: TRNodeList read FOpenList;
  end;

  function RNode(const AId: TMapDBId;
    const ANode: TRouteNode;
    const AObj: TObjectFileRef;
    const APrev: TMapDBId): TRNode;

  function CompareRNodes(const A, B: TRNode): Integer;

implementation

function RNode(const AId: TMapDBId;
  const ANode: TRouteNode;
  const AObj: TObjectFileRef;
  const APrev: TMapDBId): TRNode;
begin
  Result.Id := AId;
  Result.Node := ANode;
  Result.Prev := APrev;
  Result.Obj.Assign(AObj);
  Result.CurrentCost := 0;
  Result.EstimateCost := 0;
  Result.OverallCost := 0;
  Result.IsAccess := True;
end;

function CompareRNodes(const A, B: TRNode): Integer;
begin
  if A.OverallCost > B.OverallCost then
    Result := 1
  else
  if A.OverallCost < B.OverallCost then
    Result := -1
  else
    Result := 0;
end;

end.

